# FastAPI Project Structure - Production Architecture

This guide covers how to structure a production-grade FastAPI project based on real-world patterns from the auth-service.

## Overview: Layered Architecture

Production FastAPI projects use **clean layered architecture** for maintainability and scalability:

```
src/your_service/
├── api/                    # HTTP layer (routes, dependencies)
│   ├── deps.py            # Dependency injection
│   └── routes/
│       ├── auth.py        # Authentication endpoints
│       ├── users.py       # User management endpoints
│       └── admin.py       # Admin endpoints
├── core/                  # Application core (config, security)
│   ├── config.py          # Pydantic Settings
│   └── security.py        # JWT, password hashing, JWKS
├── db/                    # Database layer
│   └── database.py        # Engine, sessions, pooling
├── models/                # SQLAlchemy ORM models
│   └── user.py            # User, RefreshToken models
├── services/              # Business logic
│   └── email.py           # Email service
├── schemas/               # Pydantic response schemas (optional if using SQLModel)
│   └── responses.py       # API response models
├── templates/             # Email templates (Jinja2)
│   └── email/
│       └── reset_password.html
└── main.py               # FastAPI app entry point
```

## Layer 1: Database Layer (db/database.py)

### Async Engine Configuration

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base

# Connection pooling configuration
DATABASE_URL = "postgresql+asyncpg://user:password@localhost/dbname"

# Production-grade async engine setup
engine = create_async_engine(
    DATABASE_URL,
    echo=False,                          # Set to True only in development
    future=True,
    pool_size=10,                        # Base connection pool size
    max_overflow=5,                      # Additional connections if needed
    pool_recycle=3600,                   # Recycle connections after 1 hour
    pool_pre_ping=True,                  # Verify connections before use
    connect_args={
        "server_settings": {
            "application_name": "auth_service"  # Identify in DB logs
        }
    }
)

# Async session factory
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,              # Don't expire after commit
    autoflush=False,                     # Manual flush control
)

Base = declarative_base()

async def get_session() -> AsyncGenerator[AsyncSession, None]:
    """Dependency to provide database session"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()
```

### Key Production Patterns

1. **Connection Pooling**: 10 base + 5 overflow = 15 max connections
2. **Pool Recycling**: Handles database timeouts (recycle every 1 hour)
3. **Pre-ping**: Tests connections before using (prevents stale connections)
4. **Async Native**: Uses AsyncPG for non-blocking database I/O
5. **Resource Management**: Proper cleanup in finally block

---

## Layer 2: Models Layer (models/user.py)

### SQLModel Patterns

```python
from sqlmodel import SQLModel, Field, Relationship, Column, JSON
from sqlalchemy import DateTime, text
from datetime import datetime, timezone
from uuid import UUID, uuid4
from typing import Optional, List

class User(SQLModel, table=True):
    __tablename__ = "users"

    # Primary Key (UUID for distributed systems)
    id: UUID = Field(default_factory=uuid4, primary_key=True)

    # Authentication (indexed for fast lookup)
    email: str = Field(unique=True, index=True, min_length=5, max_length=255)
    username: str = Field(unique=True, index=True, min_length=3, max_length=50)
    hashed_password: str  # Never store plain text

    # Profile Information
    first_name: str = Field(default="", max_length=100)
    last_name: str = Field(default="", max_length=100)
    full_name: str = Field(default="", max_length=200)

    # Status Flags
    is_active: bool = Field(default=True)        # Soft-delete
    is_verified: bool = Field(default=False)     # Email verified

    # Role-Based Access Control
    role: str = Field(default="user")  # 'user', 'admin', 'moderator'

    # Password Reset
    forgot_password_token: Optional[str] = Field(default=None, index=True)
    forgot_password_expires_at: Optional[datetime] = None

    # Email Verification
    email_verification_token: Optional[str] = None

    # Flexible Data (JSONB in PostgreSQL)
    background_questionnaire: dict = Field(
        default_factory=dict,
        sa_column=Column(JSON),  # JSONB storage
    )

    # Timestamps (generated by database)
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column_kwargs={
            "server_default": text("current_timestamp(0)"),
            "nullable": False,
        },
    )
    updated_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column_kwargs={
            "server_default": text("current_timestamp(0)"),
            "onupdate": lambda: datetime.now(timezone.utc),
            "nullable": False,
        },
    )

    # Relationships
    refresh_tokens: List["RefreshToken"] = Relationship(
        back_populates="user",
        cascade_delete=True,  # Delete tokens when user deleted
    )


class RefreshToken(SQLModel, table=True):
    __tablename__ = "refresh_tokens"

    # Primary Key
    id: UUID = Field(default_factory=uuid4, primary_key=True)

    # Token (indexed and unique for whitelist)
    token: str = Field(unique=True, index=True)

    # Foreign Key with cascade
    user_id: UUID = Field(
        foreign_key="users.id",
        nullable=False,
        index=True,  # Index for fast user lookups
    )

    # Expiration tracking
    expires_at: datetime = Field(nullable=False)
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column_kwargs={"server_default": text("current_timestamp(0)")},
    )

    # Relationship back to user
    user: User = Relationship(back_populates="refresh_tokens")
```

### Key Model Patterns

1. **Indexes on frequently queried fields** (email, username, user_id, token)
2. **Cascade delete** (delete tokens when user deleted)
3. **JSONB for flexible data** (background_questionnaire)
4. **Server-side timestamps** (database generates, timezone-aware UTC)
5. **UUID primary keys** (better for distributed systems than auto-increment)
6. **Soft-delete flag** (is_active for reversible deletes)
7. **Relationships with typed access** (refresh_tokens list on User)

---

## Layer 3: Core Layer (core/config.py)

### Pydantic Settings Configuration

```python
from pydantic_settings import BaseSettings
from typing import Optional, List

class Settings(BaseSettings):
    """Application configuration loaded from environment variables"""

    # Application Metadata
    APP_NAME: str = "Auth Service"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = False

    # Server
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # Database (Async PostgreSQL)
    DATABASE_URL: str = "postgresql+asyncpg://user:password@localhost/auth_db"
    DATABASE_POOL_SIZE: int = 10
    DATABASE_MAX_OVERFLOW: int = 5
    DATABASE_POOL_RECYCLE: int = 3600

    # JWT Configuration (RS256 Asymmetric)
    RSA_PRIVATE_KEY_PATH: Optional[str] = None      # For local development
    RSA_PRIVATE_KEY_CONTENT: Optional[str] = None   # For environment variables
    RSA_PUBLIC_KEY_ID: str = "default"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15           # Short-lived access tokens
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7              # Longer-lived refresh tokens

    # Password Security
    PASSWORD_BCRYPT_ROUNDS: int = 12  # High cost factor (CPU-intensive)

    # Email Service (SMTP)
    SMTP_HOST: str = "smtp.gmail.com"
    SMTP_PORT: int = 587
    SMTP_USER: str = "noreply@example.com"
    SMTP_PASSWORD: str
    SMTP_SENDER_EMAIL: str = "noreply@example.com"
    SMTP_USE_TLS: bool = True
    SMTP_TIMEOUT: int = 10

    # CORS Configuration
    CORS_ORIGINS: List[str] = ["http://localhost:3000", "https://example.com"]
    CORS_ALLOW_CREDENTIALS: bool = True
    CORS_ALLOW_METHODS: List[str] = ["GET", "POST", "PUT", "DELETE", "PATCH"]
    CORS_ALLOW_HEADERS: List[str] = ["Content-Type", "Authorization"]

    class Config:
        env_file = ".env"
        case_sensitive = True
        # Nested model support
        json_encoders = {
            bytes: lambda v: v.decode()
        }

# Singleton instance
settings = Settings()
```

### Environment Variable Pattern

Create `.env` file (git-ignored):

```
# Application
APP_NAME=Auth Service
APP_VERSION=1.0.0
DEBUG=False

# Database
DATABASE_URL=postgresql+asyncpg://user:password@localhost/auth_db
DATABASE_POOL_SIZE=10

# JWT Keys (for Vercel, base64-encoded)
RSA_PRIVATE_KEY_CONTENT=LS0tLS1CRUdJTi... (base64 of PEM key)
RSA_PUBLIC_KEY_ID=default

# Tokens
ACCESS_TOKEN_EXPIRE_MINUTES=15
REFRESH_TOKEN_EXPIRE_DAYS=7

# Password
PASSWORD_BCRYPT_ROUNDS=12

# Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=noreply@example.com
SMTP_PASSWORD=your-app-specific-password
SMTP_SENDER_EMAIL=noreply@example.com

# CORS
CORS_ORIGINS=http://localhost:3000,https://example.com
```

---

## Layer 4: Security Layer (core/security.py)

### Password Hashing (Argon2 Recommended)

```python
from pwdlib import PasswordHash
from pwdlib.hashers.argon2 import Argon2Hasher

# Argon2: Winner of Password Hashing Competition (RECOMMENDED)
password_hash = PasswordHash((Argon2Hasher(),))

# Alternative: Bcrypt (legacy compatibility)
# from passlib.context import CryptContext
# pwd_context = CryptContext(
#     schemes=["bcrypt"],
#     deprecated="auto",
#     bcrypt__rounds=12,  # CPU intensive, takes ~250ms
# )
```

### RS256 JWT Implementation

```python
from jose import jwt, JWTError
from datetime import datetime, timedelta, timezone
from typing import Optional
import rsa

# RSA keys (asymmetric, production-grade)
def get_rsa_keys():
    """Load RSA public/private keys from configured sources"""
    # Priority 1: Environment variable (Vercel)
    if settings.RSA_PRIVATE_KEY_CONTENT:
        private_key = settings.RSA_PRIVATE_KEY_CONTENT
        public_key = extract_public_key(private_key)
    # Priority 2: File path (development)
    elif settings.RSA_PRIVATE_KEY_PATH:
        with open(settings.RSA_PRIVATE_KEY_PATH, 'r') as f:
            private_key = f.read()
        with open(settings.RSA_PRIVATE_KEY_PATH + '.pub', 'r') as f:
            public_key = f.read()
    else:
        raise ValueError("No RSA keys configured")

    return private_key, public_key

def hash_password(password: str) -> str:
    """Hash password with Argon2 (modern, memory-hard)"""
    return password_hash.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password with constant-time comparison (Argon2)"""
    return password_hash.verify(plain_password, hashed_password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create short-lived access token (15 minutes)"""
    to_encode = data.copy()
    to_encode["type"] = "access"  # Token type for validation

    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )

    to_encode.update({
        "exp": expire,
        "iat": datetime.now(timezone.utc),
    })

    private_key, _ = get_rsa_keys()
    encoded_jwt = jwt.encode(
        to_encode,
        private_key,
        algorithm="RS256",  # Asymmetric
    )
    return encoded_jwt

def create_refresh_token(user_id: str, expires_delta: Optional[timedelta] = None) -> str:
    """Create long-lived refresh token (7 days)"""
    data = {"sub": user_id, "type": "refresh"}

    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(
            days=settings.REFRESH_TOKEN_EXPIRE_DAYS
        )

    data.update({
        "exp": expire,
        "iat": datetime.now(timezone.utc),
    })

    private_key, _ = get_rsa_keys()
    encoded_jwt = jwt.encode(data, private_key, algorithm="RS256")
    return encoded_jwt

def verify_token(token: str, token_type: str = "access") -> dict:
    """Verify JWT signature, expiration, and type"""
    try:
        _, public_key = get_rsa_keys()
        payload = jwt.decode(token, public_key, algorithms=["RS256"])

        # Verify token type
        if payload.get("type") != token_type:
            raise JWTError("Invalid token type")

        return payload
    except JWTError as e:
        raise JWTError(f"Invalid token: {str(e)}")

def get_jwks():
    """Return JWKS (JSON Web Key Set) for distributed verification"""
    _, public_key = get_rsa_keys()
    # Convert PEM to JWKS format
    return {
        "keys": [
            {
                "kty": "RSA",
                "kid": settings.RSA_PUBLIC_KEY_ID,
                "use": "sig",
                "n": extract_n_from_public_key(public_key),
                "e": "AQAB",  # Standard RSA exponent
            }
        ]
    }
```

### Key Security Patterns

1. **RS256 (Asymmetric)**: Private key for signing, public key for verification
2. **Token Type Field**: Each token includes `"type": "access"` or `"type": "refresh"`
3. **Bcrypt Cost Factor 12**: CPU-intensive, resistant to brute force
4. **Short Access Token**: 15 minutes (limit compromise window)
5. **Longer Refresh Token**: 7 days (seamless experience)
6. **JWKS Endpoint**: Public key distribution for distributed systems
7. **Dual-mode Key Loading**: File path (dev) + environment variable (production)

---

## Layer 5: Dependencies Layer (api/deps.py)

### Dependency Injection

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthenticationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional

security = HTTPBearer()

async def get_db(db: AsyncSession = Depends(get_session)) -> AsyncSession:
    """Provide database session"""
    return db

async def get_current_user(
    credentials: HTTPAuthenticationCredentials = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Extract and validate JWT token, fetch user from database"""
    token = credentials.credentials

    try:
        payload = verify_token(token, token_type="access")
        user_id = payload.get("sub")
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Fetch user from database
    user = await db.get(User, UUID(user_id))
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
        )

    return user

async def get_current_admin(
    current_user: User = Depends(get_current_user)
) -> User:
    """Validate admin role"""
    if current_user.role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions",
        )
    return current_user

# Usage in routes
@router.get("/user/me")
async def get_user_profile(
    current_user: User = Depends(get_current_user)
):
    """Get current user profile"""
    return current_user

@router.get("/admin/users")
async def list_users(
    current_user: User = Depends(get_current_admin),
    db: AsyncSession = Depends(get_db),
):
    """List users (admin-only)"""
    statement = select(User).limit(100)
    result = await db.execute(statement)
    return result.scalars().all()
```

---

## Layer 6: Routes Layer (api/routes/auth.py)

### RESTful Endpoint Patterns

```python
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import timedelta

router = APIRouter(prefix="/api/v1", tags=["auth"])

# Response Schema
class TokenResponse(SQLModel):
    access_token: str
    refresh_token: str
    expires_in: int
    token_type: str = "Bearer"

# Sign Up (Create User)
@router.post(
    "/sign-up",
    response_model=TokenResponse,
    status_code=status.HTTP_201_CREATED,  # Resource created
)
async def sign_up(
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db),
):
    """Register new user"""
    # Check if user exists
    existing = await db.execute(
        select(User).where(User.email == user_data.email)
    )
    if existing.scalar():
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,  # Resource exists
            detail="Email already registered"
        )

    # Create user
    db_user = User(
        email=user_data.email,
        username=user_data.username,
        hashed_password=hash_password(user_data.password),
        first_name=user_data.first_name,
        last_name=user_data.last_name,
    )
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)

    # Generate tokens
    access_token = create_access_token({"sub": str(db_user.id)})
    refresh_token = create_refresh_token(str(db_user.id))

    # Store refresh token in whitelist
    token_obj = RefreshToken(
        token=refresh_token,
        user_id=db_user.id,
        expires_at=datetime.now(timezone.utc) + timedelta(days=7),
    )
    db.add(token_obj)
    await db.commit()

    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
    )

# Login
@router.post("/login", response_model=TokenResponse)
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db),
):
    """Authenticate user"""
    # Find user
    result = await db.execute(
        select(User).where(User.email == form_data.username)
    )
    user = result.scalar()

    # Verify credentials
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User account is inactive",
        )

    # Revoke all existing refresh tokens (single-session enforcement)
    await db.execute(
        delete(RefreshToken).where(RefreshToken.user_id == user.id)
    )

    # Create new tokens
    access_token = create_access_token({"sub": str(user.id)})
    refresh_token = create_refresh_token(str(user.id))

    # Store new refresh token
    token_obj = RefreshToken(
        token=refresh_token,
        user_id=user.id,
        expires_at=datetime.now(timezone.utc) + timedelta(days=7),
    )
    db.add(token_obj)
    await db.commit()

    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
    )

# Refresh Token
@router.post("/refresh", response_model=TokenResponse)
async def refresh_token(
    token_request: dict,
    db: AsyncSession = Depends(get_db),
):
    """Get new access token using refresh token (rotate tokens)"""
    refresh_token = token_request.get("refresh_token")

    # Verify refresh token
    try:
        payload = verify_token(refresh_token, token_type="refresh")
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)

    # Check if token is in whitelist
    result = await db.execute(
        select(RefreshToken).where(RefreshToken.token == refresh_token)
    )
    db_token = result.scalar()

    if not db_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Refresh token has been revoked"
        )

    # Delete old refresh token (rotation)
    await db.delete(db_token)

    # Create new tokens
    user_id = payload.get("sub")
    new_access_token = create_access_token({"sub": user_id})
    new_refresh_token = create_refresh_token(user_id)

    # Store new refresh token
    new_token_obj = RefreshToken(
        token=new_refresh_token,
        user_id=UUID(user_id),
        expires_at=datetime.now(timezone.utc) + timedelta(days=7),
    )
    db.add(new_token_obj)
    await db.commit()

    return TokenResponse(
        access_token=new_access_token,
        refresh_token=new_refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
    )

# Logout
@router.post("/logout", status_code=status.HTTP_204_NO_CONTENT)
async def logout(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Revoke refresh token"""
    # Delete all refresh tokens for user (logout from all devices)
    await db.execute(
        delete(RefreshToken).where(RefreshToken.user_id == current_user.id)
    )
    await db.commit()
    # Return 204 with no content
```

### Key Endpoint Patterns

1. **Status Codes**: 201 (created), 200 (ok), 204 (no content), 401 (unauthorized), 409 (conflict)
2. **Single-Session**: Delete all tokens on login (logout from other devices)
3. **Token Rotation**: Delete old refresh token before issuing new pair
4. **WWW-Authenticate Header**: Standard for 401 responses
5. **Consistent Response Schema**: TokenResponse with all required fields
6. **Error Privacy**: Don't reveal whether user exists (prevent enumeration)

---

## Best Practices Summary

| Aspect | Pattern |
|--------|---------|
| **Structure** | Layered (API, Core, DB, Models, Services) |
| **Database** | Async SQLAlchemy with connection pooling |
| **Models** | SQLModel combining ORM + Pydantic validation |
| **Security** | RS256 asymmetric JWT with token rotation |
| **Passwords** | Bcrypt with cost factor 12 |
| **Configuration** | Pydantic Settings from environment |
| **Endpoints** | RESTful with proper status codes |
| **Dependencies** | FastAPI Depends for injection |
| **Errors** | HTTPException with proper status codes |
| **Tokens** | Short-lived access (15 min) + long-lived refresh (7 days) |

This structure scales from small services to enterprise microservices while maintaining code clarity and security.
